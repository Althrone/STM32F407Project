#include "main.h"
#include "arm_math.h"

/* ----------------------------------------------------------------------
* Defines each of the tests performed
* ------------------------------------------------------------------- */
#define MAX_BLOCKSIZE   32
#define DELTA           (0.0001f)


/* ----------------------------------------------------------------------
* Test input data for Floating point sin_cos example for 32-blockSize
* Generated by the MATLAB randn() function
* ------------------------------------------------------------------- */

const float32_t testInput_f32[MAX_BLOCKSIZE] =
{
  -1.244916875853235400,  -4.793533929171324800,   0.360705030233248850,   0.827929644170887320,  -3.299532218312426900,   3.427441903227623800,   3.422401784294607700,  -0.108308165334010680,
   0.941943896490312180,   0.502609575000365850,  -0.537345278736373500,   2.088817392965764500,  -1.693168684143455700,   6.283185307179590700,  -0.392545884746175080,   0.327893095115825040,
   3.070147440456292300,   0.170611405884662230,  -0.275275082396073010,  -2.395492805446796300,   0.847311163536506600,  -3.845517018083148800,   2.055818378415868300,   4.672594161978930800,
  -1.990923030266425800,   2.469305197656249500,   3.609002606064021000,  -4.586736582331667500,  -4.147080139136136300,   1.643756718868359500,  -1.150866392366494800,   1.985805026477433800


};

const float32_t testRefOutput_f32 = 1.000000000;

/* ----------------------------------------------------------------------
* Declare Global variables
* ------------------------------------------------------------------- */
uint32_t blockSize = 32;
float32_t  testOutput;
float32_t  cosOutput;
float32_t  sinOutput;
float32_t  cosSquareOutput;
float32_t  sinSquareOutput;

/* ----------------------------------------------------------------------
* Max magnitude FFT Bin test
* ------------------------------------------------------------------- */

arm_status status;

int main(void)
{

  float32_t diff;
  uint32_t i;

  for(i=0; i< blockSize; i++)
  {
    cosOutput = arm_cos_f32(testInput_f32[i]);
    sinOutput = arm_sin_f32(testInput_f32[i]);

    arm_mult_f32(&cosOutput, &cosOutput, &cosSquareOutput, 1);
    arm_mult_f32(&sinOutput, &sinOutput, &sinSquareOutput, 1);

    arm_add_f32(&cosSquareOutput, &sinSquareOutput, &testOutput, 1);

    /* absolute value of difference between ref and test */
    diff = fabsf(testRefOutput_f32 - testOutput);

    /* Comparison of sin_cos value with reference */
    if(diff > DELTA)
    {
       status = ARM_MATH_TEST_FAILURE;
    }

    if( status == ARM_MATH_TEST_FAILURE)
    {
       while(1);
    }

  }

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置系统中断优先级分组2

    RGBLED_Init();
    TIM6_Init();

    IIC_Init();
    USART1_Init();

    PPM_Init();

    MPU6050_Init();
    SPL06_Init();
    AK8975_Init();

    Motor_Init();
    Steer_Init();

    //校准代码区
    //获取遥控器数值


    ANO_DT_SendSenserTypeDef ANO_DT_SendSenserStruct;//发送到上位机的传感器数据结构体
    ANO_DT_SendRCDataTypeDef ANO_DT_SendRCDataStruct;//发送到上位机的遥控数据
    ANO_DT_SendStatusTypeDef ANO_DT_SendStatusStruct;//无人机当前姿态，这里我只是随便塞两个数进去看看

    MPU6050_RawDataTypeDef MPU6050_RawDataStruct;
    MPU6050_FloatDataTypeDef MPU6050_FloatDataStruct;

    SPL06_RawDataTypeDef SPL06_RawDataStruct;
    SPL06_FloatDataTypeDef SPL06_FloatDataStruct;

    AK8975_RawDataTypeDef AK8975_RawDataStruct;
    AK8975_FloatDataTypeDef AK8975_FloatDataStruct;

    ATT_AngleDataTypeDef ATT_AngleDataStruct;
    ATT_QuatDataTypeDef ATT_QuatDataStruct;

    Motor_PWMTypeDef Motor_PWMStruct;


    while (1)
    {
        MPU6050_AllRawDataRead(&MPU6050_RawDataStruct);
        AK8975_AllRawDataRead(&AK8975_RawDataStruct);
        SPL06_AllRawDataRead(&SPL06_RawDataStruct);

        MPU6050_RawData2FloatData(&MPU6050_RawDataStruct,&MPU6050_FloatDataStruct);
        AK8975_RawData2FloatData(&AK8975_RawDataStruct,&AK8975_FloatDataStruct);
        SPL06_RawData2FloatData(&SPL06_RawDataStruct,&SPL06_FloatDataStruct);

        PPM_GetRCData(&ANO_DT_SendRCDataStruct);

        Steer_Test(&ANO_DT_SendRCDataStruct);

        Motor_PWMStruct.PWM1=ANO_DT_SendRCDataStruct.ANO_DT_RCThrottle;
        Motor_PWMStruct.PWM2=ANO_DT_SendRCDataStruct.ANO_DT_RCThrottle;
        Motor_PWMStruct.PWM3=ANO_DT_SendRCDataStruct.ANO_DT_RCThrottle;
        Motor_PWMStruct.PWM4=ANO_DT_SendRCDataStruct.ANO_DT_RCThrottle;
        Motor_PWM(&Motor_PWMStruct);

        ATT_RawData(&MPU6050_FloatDataStruct,&AK8975_FloatDataStruct,&ATT_AngleDataStruct);
        ATT_Angle2Quat(&ATT_AngleDataStruct,&ATT_QuatDataStruct);
        ATT_Quat2Angle(&ATT_QuatDataStruct,&ATT_AngleDataStruct);

        ANO_DT_SendStatusStruct.ANO_DT_Pitch=(int16_t)(ATT_AngleDataStruct.ATT_AngleTheta*100);
        ANO_DT_SendStatusStruct.ANO_DT_Roll=(int16_t)(ATT_AngleDataStruct.ATT_AnglePhi*100);
        ANO_DT_SendStatusStruct.ANO_DT_Yaw=(int16_t)(ATT_AngleDataStruct.ATT_AnglePsi*100);

        ANO_DT_SendSenserStruct.ANO_DT_AccX=MPU6050_RawDataStruct.MPU6050_RawAccelX;
        ANO_DT_SendSenserStruct.ANO_DT_AccY=MPU6050_RawDataStruct.MPU6050_RawAccelY;
        ANO_DT_SendSenserStruct.ANO_DT_AccZ=MPU6050_RawDataStruct.MPU6050_RawAccelZ;
        ANO_DT_SendSenserStruct.ANO_DT_GyroX=MPU6050_RawDataStruct.MPU6050_RawGyroX;
        ANO_DT_SendSenserStruct.ANO_DT_GyroY=MPU6050_RawDataStruct.MPU6050_RawGyroY;
        ANO_DT_SendSenserStruct.ANO_DT_GyroZ=MPU6050_RawDataStruct.MPU6050_RawGyroZ;
        ANO_DT_SendSenserStruct.ANO_DT_MagX=AK8975_RawDataStruct.AK8975_RawMagX;
        ANO_DT_SendSenserStruct.ANO_DT_MagY=AK8975_RawDataStruct.AK8975_RawMagY;
        ANO_DT_SendSenserStruct.ANO_DT_MagZ=AK8975_RawDataStruct.AK8975_RawMagZ;
        ANO_DT_SendSenser(USART1,&ANO_DT_SendSenserStruct);

        ANO_DT_SendRCData(USART1,&ANO_DT_SendRCDataStruct);
        ANO_DT_SendStatus(USART1,&ANO_DT_SendStatusStruct);


    }
}